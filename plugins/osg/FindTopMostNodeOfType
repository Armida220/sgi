// kate: syntax C++11;
// SGI - Copyright (C) 2012-2015 FAST Protect, Andreas Roth

#pragma once

#include <osg/NodeVisitor>

namespace sgi {

namespace details {
    /**
     * Visitor that locates a node by its type
     */
	template<typename T>
	class FindTopMostNodeOfTypeVisitor : public osg::NodeVisitor
	{
	public:
		FindTopMostNodeOfTypeVisitor(osg::NodeVisitor::TraversalMode mode = osg::NodeVisitor::TRAVERSE_ALL_CHILDREN, unsigned traversalMask = ~0u)
			: osg::NodeVisitor(mode)
			, _foundNode(NULL)
			, _excludedNode(NULL)
		{
			setTraversalMask(traversalMask);
		}

		void apply(osg::Node& node)
		{
			T* result = dynamic_cast<T*>(&node);
			if (result && result != _excludedNode)
			{
				_foundNode = result;
			}
			else
			{
				traverse(node);
			}
		}

		T* foundNode() const { return _foundNode; }
		T* excludedNode() const { return _excludedNode; }
		void setExcludedNode(T * node) { _excludedNode = node; }
		bool found() const { return _foundNode != NULL; }
	private:
		T* _foundNode;
		T* _excludedNode;
	};
} // namespace details

/**
 * Searchs the scene graph upward starting at [node] and returns the first node found
 * that matches the template parameter type.
 */
template<typename T>
T* findFirstParentOfType(osg::Node* node, unsigned traversalMask =~0u, T * excludedNode=NULL)
{
    if (!node) return 0;

    details::FindTopMostNodeOfTypeVisitor<T> fnotv(osg::NodeVisitor::TRAVERSE_PARENTS, traversalMask);
	fnotv.setExcludedNode(excludedNode);
    node->accept(fnotv);

    return fnotv.foundNode();
}

} // namespace sgi
