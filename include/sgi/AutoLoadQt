// kate: syntax C++11;
/* -*-c++-*- OpenSceneGraph - Copyright (C) 1998-2006 Robert Osfield
 *
 * This library is open source and may be redistributed and/or modified under
 * the terms of the OpenSceneGraph Public License (OSGPL) version 0.0 or
 * (at your option) any later version.  The full license is in LICENSE file
 * included with this distribution, and on the openscenegraph.org website.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * OpenSceneGraph Public License for more details.
*/
//sgi - Copyright (C) 2012-2013 Andreas Roth

#pragma once

#include "Export"

#if !defined(_WIN32)
#include <QtCore/QCoreApplication>
#endif
#include <QtCore/QLibrary>

namespace sgi {
    namespace autoload {
    class Qt
    {
    public:
        typedef void * PROC_ADDRESS;
        Qt()
        {
#ifdef _WIN32
            // on Win32 the terra3d-sgi.dll is in the same directory as the application
            // and no further path tricks are required.
            _library = new QLibrary(SGI_LIBRARY_NAME);
#else
            // on linux the terra3d-sgi.so is in the lib directory, but the application
            // is started from the bin directory. So a little trick is required to find
            // the library.
            QString libfile = QCoreApplication::applicationDirPath() + QString("/../lib/" SGI_LIBRARY_NAME);
            _library = new QLibrary(libfile);
#endif
        }
        ~Qt()
        {
            delete _library;
        }
        QLibrary * library()
        {
            return _library;
        }
        PROC_ADDRESS getProcAddress(const char* procName)
        {
            return (_library)?(PROC_ADDRESS)_library->resolve(procName):NULL;
        }
        std::string libraryFilename() const
        {
            return (_library)?_library->fileName().toStdString():NULL;
        }
        std::string libraryError() const
        {
            return (_library)?_library->errorString().toStdString():std::string("Unknown");
        }
        static Qt & instance()
        {
            static Qt s_sgi;
            return s_sgi;
        }
        static inline QLibrary * sgiLibrary()
        {
            return Qt::instance().library();
        }
        static inline void * sgiLibraryProcAddress(const char * procName)
        {
            return Qt::instance().getProcAddress(procName);
        }
        static inline std::string sgiLibraryName()
        {
            return std::string(SGI_LIBRARY_NAME);
        }
        static inline std::string sgiLibraryFilename()
        {
            return Qt::instance().libraryFilename();
        }
        static inline bool sgiLibraryLoaded()
        {
            return Qt::instance().library() != NULL;
        }

    private:
        QLibrary * _library;
    };


} } // namespace sgi::autoload
