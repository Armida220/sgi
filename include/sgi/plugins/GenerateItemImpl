// kate: mode C++;
// SGI - Copyright (C) 2012-2015 FAST Protect, Andreas Roth

#pragma once
#include <sgi/details/call_function_for_object_type>

namespace sgi {

// forward declaration
template<template<typename> class generateItemAcceptImplTemplate, typename ...ITEM_TYPE>
struct generateItemImplT;

namespace details {

template<typename SGIItemClassT, template<typename> class generateSGIItemImplTemplate>
class generateSGIItemT
{
public:
    typedef SGIItemClassT SGIItemClass;
    typedef typename SGIItemClassT::ObjectStorageType ObjectStorageType;
    typedef typename SGIItemClassT::HostItemType HostItemType;
    generateSGIItemT(const HostItemType * hostItem)
        : _hostItem(hostItem), _level(0), _itemChain(NULL)
    {
    }
    template<typename T>
    void ascend(T * object)
    {
        _level--;
    }
    template<typename T>
    void decend(T * object)
    {
        _level++;
    }
    template<typename T>
    void accept(T * object)
    {
        SGIItemType itemType = generateSGIItemImplTemplate<T>::ItemType::value;
        SGIItemClass * newItem = new SGIItemClass(_hostItem, itemType, object, 0, _level, _hostItem->userDataPtr());
        newItem->setTypeInfo(typeid(T));
        if(_itemChain.valid())
            _itemChain->insertBefore(newItem);
        _itemChain = newItem;
    }
    template<typename T>
    bool canAccept(T * object)
    {
        return generateSGIItemImplTemplate<T>::accept::value;
    }
    bool wasAccepted() const
    {
        return _itemChain.valid();
    }
    SGIItemClass * getItem()
    {
        return (SGIItemClass *)_itemChain.get();
    }

private:
    const HostItemType * _hostItem;
    unsigned    _level;
    SGIItemBasePtr _itemChain;
};

template<typename ITEM_TYPE, template<typename> class generateItemAcceptImplTemplate>
struct generateSGIItem_BaseT
{
    typedef typename ITEM_TYPE::HostItemType HostItemType;
    typedef typename HostItemType::ObjectType ObjectType;
    static bool generate(const HostItemType * hostItem, SGIItemBasePtr & item)
    {
        typedef generateSGIItemT<ITEM_TYPE, generateItemAcceptImplTemplate> generateSGIItemFunctor;
        generateSGIItemFunctor func(hostItem);
        call_function_for_object_type<ObjectType, ObjectType>(hostItem->object(), func);
        bool ret = func.wasAccepted();
        if(ret)
            item = func.getItem();
        return ret;
    }
};

} // namespace details

template<template<typename> class generateItemAcceptImplTemplate, typename ...ITEM_TYPE>
struct generateItemImplT
{
    typedef details::type_list<ITEM_TYPE...> item_types;
    struct call_proxy
    {
        const SGIHostItemBase * _hostItem;
        SGIItemBasePtr & _item;
        bool _ret;
        call_proxy(const SGIHostItemBase * hostItem, SGIItemBasePtr & item)
            : _hostItem(hostItem), _item(item), _ret(false) {}

        template<typename SINGLE_ITEM_TYPE>
        void operator()()
        {
            typedef typename SINGLE_ITEM_TYPE::HostItemType HostItemType;
            const HostItemType* targetHostItem = dynamic_cast<const HostItemType*>(_hostItem);
            if(targetHostItem)
                _ret = details::generateSGIItem_BaseT<SINGLE_ITEM_TYPE, generateItemAcceptImplTemplate>::generate(targetHostItem, _item);
        }
    };
    static bool generate(const SGIHostItemBase * object, SGIItemBasePtr & item)
    {
        call_proxy func(object, item);
        details::for_each_type<item_types>(func);
        return func._ret;
    }
};

} // namespace sgi
